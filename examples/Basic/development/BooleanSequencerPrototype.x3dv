#X3D V3.0 utf8
# X3D-to-ClassicVRML XSL translation autogenerated by X3dToVrml97.xslt
# http://www.web3d.org/x3d/content/X3dToVrml97.xslt
# Generated using XSLT processor: SAXON 8.7 from Saxonica

PROFILE Immersive
# [X3D] version=3.0
# [X3D] noNamespaceSchemaLocation=http://www.web3d.org/specifications/x3d-3.0.xsd
# [head]

META "title" "BooleanSequencerPrototype.x3d"
META "description" "BooleanSequencer is modeled after ScalarInterpolator and generates true or false values."
META "creator" "Don Brutzman, Estuko Lippi, Jeff Weekley, Jane Wu"
META "created" "7 August 2001"
META "modified" "25 December 2005"
META "reference" "http://www.web3d.org/technicalinfo/specifications/vrml97/part1/nodesRef.html#ScalarInterpolator"
META "subject" "boolean sequencer"
META "identifier" "http://www.web3d.org/x3d/content/examples/Basic/development/BooleanSequencerPrototype.x3d"
META "generator" "X3D-Edit, http://www.web3d.org/x3d/content/README.X3D-Edit.html"
META "license" "../../license.html"

# [Scene] ========== ========== ==========

NavigationInfo { type [ "EXAMINE" "ANY" ] } ###  Default X3D NavigationInfo

PROTO BooleanSequencer [
  # Regular interpolator-style input
  inputOnly      SFFloat	set_fraction    # [appinfo] typical range [0..1]

  inputOnly      MFFloat	set_key
   ### Warning:  Initializing MFFloat value not provided for field 'key' with @accessType='inputOutput'
inputOutput    MFFloat	key [ ]    # [appinfo] Array sequentially increasing, typically [0..1].  Must have the same number of keys as keyValues.

  outputOnly     MFFloat	key_changed
  inputOnly      SFString	set_keyValue # type MFBool 
   ### Warning:  Initializing MFBool value not provided for field 'keyValue' with @accessType='inputOutput'
inputOutput    SFString	keyValue "" # type MFBool     # [appinfo] Array of true|false values.  Must have the same number of keys as keyValues.

  outputOnly     SFString	keyValue_changed # type MFBool 
  # Regular interpolator-style output
  outputOnly     SFBool	value_changed
  # Utility methods
  inputOnly      SFBool	previous
  inputOnly      SFBool	next
] {
  Group {
    children [
        DEF KeyHolder ScalarInterpolator {
                      key IS key
        }
        DEF KeyValueHolder Anchor {
                      description IS keyValue
        }
        DEF SequencerScript Script {
          # Regular interpolator-style input
          inputOnly      SFFloat	set_fraction IS set_fraction            # [appinfo] typical range [0..1]

          inputOnly      MFFloat	set_key IS set_key            # [appinfo] Array sequentially increasing, typically [0..1].  Must have the same number of keys as keyValues.

          initializeOnly SFNode      keyHolderNode             USE KeyHolder
          outputOnly     MFFloat	key_changed IS key_changed
          inputOnly      SFString	set_keyValue IS set_keyValue # type MFBool             # [appinfo] Array of true or false values.  Must have the same number of keys as keyValues.

          initializeOnly SFNode      keyValueHolderNode             USE KeyValueHolder
          outputOnly     SFString	keyValue_changed IS keyValue_changed # type MFBool 
          # Regular interpolator-style output
          outputOnly     SFBool	value_changed IS value_changed
          # Utility methods
          inputOnly      SFBool	previous IS previous
          inputOnly      SFBool	next IS next
          # Script-specific interfaces, not needed for node definition
          initializeOnly SFBool	traceEnabled FALSE
           ### Warning:  Initializing MFInt32 value not provided for field 'keyValueArray' with @accessType='initializeOnly'
initializeOnly MFInt32	keyValueArray [ ]
          initializeOnly SFFloat	previousFraction 0.0
          initializeOnly SFInt32	nextIndex 0
          initializeOnly SFBool	valid TRUE
          initializeOnly SFBool	recheckValidity FALSE
          initializeOnly SFBool	forward TRUE            # [appinfo] leftToRight

          directOutput TRUE
          # Regular interpolator-style input
          # Regular interpolator-style output
          # Utility methods
          # Script-specific interfaces, not needed for node definition
                                                                                                           ### Warning:  inputOnly field 'previous' has no input-event method definition 'function previous (SFBoolValue, timestamp) { }' in contained ecmascript: code
 ### Warning:  inputOnly field 'next' has no input-event method definition 'function next (SFBoolValue, timestamp) { }' in contained ecmascript: code
 ### Warning:  'var' declarations of variables are not persistent in contained ecmascript: code, values are lost after each call. Use <field> definitions instead.
 ### Warning:  mismatched (i.e. odd number of) 'single quote' marks in contained ecmascript: code

	url [ "ecmascript:
// ### X3D Browser.print() not supported by all VRML97 viewers, instead simply use print()


var key, keyValue;

function initialize(timeStamp)
{
	key      = keyHolderNode.key;
	keyValue = keyValueHolderNode.description;
	tracePrint('key = ' + key);
	tracePrint('keyValue = ' + keyValue);
	keyValueToKeyValueArray ();
	tracePrint('keyValueArray = ' + keyValueArray);

	forward = true;
	tracePrint('Initializing a new BooleanSequencer.  key.length=' + key.length +
		'; keyValueArray.length=' + keyValueArray.length);
	validityCheck();
}

function keyValueToKeyValueArray ()
{
	tracePrint('keyValueToKeyValueArray starting');
	index = 0;
	complete = false;
	nextString = keyValue.toLowerCase();
	tracePrint('initial nextString=' + nextString);
	tokenCount=0;
	while ((complete != true) && (nextString.length > 0))
	{
		tracePrint('nextString=' + nextString);
		while ((nextString.substring(0,1) == ' ') || (nextString.substring(0,1) == ','))
		       nextString = nextString.slice(1);
		tracePrint('deblanked nextString=' + nextString);
		if (nextString.length == 0)
		{
			tracePrint ('nextString.length == 0');
			complete = true;
		}
		if (nextString.length < 4)
		{
			forcePrint ('*** illegal keyValue input=' + nextString);
			valid = false;
			complete = true;
		}
		else if (nextString.substring(0,4) == 'true')
		{
			keyValueArray[keyValueArray.length] = 1; // append
			newString = nextString.slice(4);
			nextString = newString;
			tokenCount++;
			tracePrint('found true, nextString=' + nextString + ', tokenCount=' + tokenCount);
		}
		else if (nextString.length < 5)
		{
			forcePrint ('*** illegal keyValue input=' + nextString);
			valid = false;
			complete = true;
		}
		else if (nextString.substring(0,5) == 'false')
		{
			keyValueArray[keyValueArray.length] = 0; // append
			newString = nextString.slice(5);
			nextString = newString;
			tokenCount++;
			tracePrint('found false, nextString=' + nextString + ', tokenCount=' + tokenCount);
		}
		tracePrint('  intermediate keyValueArray=' + keyValueArray);
	}
	tracePrint('keyValueToKeyValueArray complete');
}

function set_fraction(value, timeStamp)
{
	if (recheckValidity) validityCheck();

	if (!valid) return; //BooleanSequencer ignored

	tracePrint('fraction = ' + value);
	//Bounds checking
	if (value < 0)
	{
		forcePrint('*** warning: fraction is less than 0.  fraction reset to 0 ***');
		value = 0;
	}
	else if (value > 1)
	{
		forcePrint('*** warning: fraction is greater than 1.  fraction reset to 1 ***');
		value = 1;
	}

	//Check animation direction
	if (value < previousFraction && forward == true)
	{
		forward = false;
		nextIndex = nextIndex - 1;
		tracePrint('Animate backward');
	}
	else if (value > previousFraction && forward == false)
	{
		forward = true;
		//nextIndex = 0;
		tracePrint('Animate forward');
	}

	previousFraction = value;

	if (forward == true)
	{
		for (i = nextIndex; i < key.length; i++)
		{
			if (value < key[i])
				return;

			nextIndex = i + 1;
			tracePrint('nextIndex = ' + nextIndex);
			if (nextIndex < key.length)
			{
				if (value <= key[nextIndex])
				{
					//Fire event
					if (keyValueArray[nextIndex-1] == 0)
						value_changed = false;
					else
						value_changed = true;
					tracePrint('value_changed eventOut is: ' + value_changed);
				}
			}
			else if (nextIndex == key.length)
			{
				//Fire event
				if (keyValueArray[nextIndex-1] == 0)
					value_changed = false;
				else
					value_changed = true;
				tracePrint('value_changed eventOut is: ' + value_changed);
			}
			else //nextIndex > key.length
			{
				//nextIndex = 0;
				break;
			}
		}
	}
	else //backward
	{
		for (i = nextIndex; i > 0; i--)
		{
			if (value >= key[i])
				return;

			nextIndex = i - 1;
			tracePrint('nextIndex = ' + nextIndex);
			if (nextIndex >= 0)
			{
				if (value >= key[nextIndex])
				{
					//Fire event
					if (keyValueArray[nextIndex] == 0)
						value_changed = false;
					else
						value_changed = true;
					tracePrint('value_changed eventOut is: ' + value_changed);
				}
			}
			else //nextIndex < 0
			{
				//nextIndex = key.length;
				break;
			}
		}
	}
}

function set_key(value, timeStamp)
{
	key = value;
	keyHolderNode.key  = key;
	recheckValidity = true;
}

function set_keyValue(value, timeStamp)
{
	keyValue = value;
	keyValueHolderNode.description = keyValue;
	recheckValidity = true;
	keyValueToKeyValueArray ();
	keyValue_changed = keyValue;
}

function validityCheck()
{
	//Check if key & keyValueArray array length matches
	if (key.length != keyValueArray.length)
	{
		forcePrint('*** error: key and keyValue arrays must be of the same length.  BooleanSequencer ignored ***');
		valid = false;
		return;
	}

	//Check if key array has values in the range of [0..1] in an increasing order
	if (key[0] < 0 || key[0] > 1)
	{
		forcePrint('*** error: key[0] value is NOT in the range of [0..1].  BooleanSequencer ignored ***');
		valid = false;
		return;
	}
	for (i = 1; i < key.length; i++)
	{
		if (key[i] < 0 || key[i] > 1)
		{
			forcePrint('*** error: key[' + i + '] value is NOT in the range of [0..1].  BooleanSequencer ignored ***');
			valid = false;
			return;
		}

		if (key[i] <= key [i-1])
		{
			forcePrint('*** error: key array\'s values must be listed in an increasing order.  BooleanSequencer ignored ***');
			valid = false;
			return;
		}
	}
	recheckValidity = false;
	key_changed = key;
	return;
}

function tracePrint(outputString)
{
	if (traceEnabled) Browser.print ('[ BooleanSequencer ] ' + outputString);
}

function forcePrint(outputString)
{
	Browser.print ('[ BooleanSequencer ] ' + outputString);
}
          
" ]
        }
    ]
  }
}
# ===============Example==============
Anchor {
  description "BooleanSequencerExample"
  parameter [ "target=_blank" ]
  url [ "BooleanSequencerExample.wrl"
"https://savage.nps.edu/Savage/Tools/Animation/BooleanSequencerExample.wrl"
"http://www.web3d.org/x3d/content/examples/Basic/development/BooleanSequencerExample.wrl"
"BooleanSequencerExample.x3d"
"https://savage.nps.edu/Savage/Tools/Animation/BooleanSequencerExample.x3d"
"http://www.web3d.org/x3d/content/examples/Basic/development/BooleanSequencerExample.x3d" ]
  children [
      Shape {
        geometry Text {
          string [ "BooleanSequencerPrototype" "defines a prototype" ""
"Click on this text to see" "BooleanSequencerExample" " scene" ]
          fontStyle FontStyle {
            justify [ "MIDDLE" "MIDDLE"  ] 
          }
        }
        appearance Appearance {
          material Material {
            diffuseColor 1 1 0.2
          }
        }
      }
  ]
}
