#X3D V3.0 utf8
# X3D-to-ClassicVRML XSL translation autogenerated by X3dToVrml97.xslt
# http://www.web3d.org/x3d/content/X3dToVrml97.xslt
# Generated using XSLT processor: SAXON 8.7 from Saxonica

PROFILE Immersive
# [X3D] version=3.0
# [X3D] noNamespaceSchemaLocation=http://www.web3d.org/specifications/x3d-3.0.xsd
# [head]

META "title" "CoordinateInterpolator2dPrototype.x3d"
META "description" "CoordinateInterpolator2D prototype declaration, to interpolate across an array of Vector2FloatArray/MFVec2f values to produce an interpolated Vector2FloatArray - click text to see example."
META "creator" "Don Brutzman, Jeff Weekley, Jane Wu"
META "created" "28 June 2001"
META "modified" "25 December 2005"
META "reference" "http://www.web3d.org/technicalinfo/specifications/vrml97/part1/concepts.html#4.6.8"
META "reference" "http://www.web3d.org/technicalinfo/specifications/vrml97/part1/nodesRef.html#CoordinateInterpolator"
META "subject" "CoordinateInterpolator2D"
META "identifier" "http://www.web3d.org/x3d/content/examples/Basic/development/CoordinateInterpolator2dPrototype.x3d"
META "generator" "X3D-Edit, http://www.web3d.org/x3d/content/README.X3D-Edit.html"
META "license" "../../license.html"

# [Scene] ========== ========== ==========

NavigationInfo { type [ "EXAMINE" "ANY" ] } ###  Default X3D NavigationInfo

PROTO CoordinateInterpolator2D [
  # [appinfo] Provide interpolation capability for Vector2FloatArray/MFVec2f values


 # documentation: http://www.web3d.org/technicalinfo/specifications/vrml97/part1/concepts.html#4.6.8

  # Regular interpolator-style input
  inputOnly      SFFloat	set_fraction    # [appinfo] The set_fraction eventIn receives an SFFloat event and causes the interpolator function to evaluate, resulting in a value_changed eventOut with the same timestamp as the set_fraction event.

  inputOnly      MFFloat	set_key
   ### Warning:  Initializing MFFloat value not provided for field 'key' with @accessType='inputOutput'
inputOutput    MFFloat	key [ ]    # [appinfo] keyValue holds the array of Vector2FloatArrays that match each animation key.

  outputOnly     MFFloat	key_changed    # [appinfo] Array sequentially increasing, typically [0..1].  Must have the same number of keys as keyValues.

  inputOnly      MFVec2f	set_keyValue    # [appinfo] Array of integer values.  Must have the same number of keys as keyValues.

   ### Warning:  Initializing MFVec2f value not provided for field 'keyValue' with @accessType='inputOutput'
inputOutput    MFVec2f	keyValue [ ]    # [appinfo] keyValue holds the array of Vector2FloatArrays that match each animation key.

  outputOnly     MFVec2f	keyValue_changed    # [appinfo] Array of integer values.  Must have the same number of keys as keyValues.

  # Regular interpolator-style output
  outputOnly     MFVec2f	value_changed    # [appinfo] The interpolator function averages between respective keyValue Vector2FloatArrays, resulting in a Vector2FloatArray value_changed eventOut with the same timestamp as the set_fraction event.

] {
  Group {
    children [
        Switch {
          children [
            DEF KeyHolder ScalarInterpolator {
                              key IS key
            }
            Shape {
              geometry IndexedFaceSet {
                texCoord DEF KeyValueHolder TextureCoordinate {
                                      point IS keyValue
                }
              }
            }
          ]
        }
        DEF InterpolationScript Script {
          inputOnly      SFFloat	set_fraction IS set_fraction
           ### Warning:  Initializing SFFloat value not provided for field 'fraction' with @accessType='initializeOnly'
initializeOnly SFFloat	fraction 0.0            # [appinfo] local variable

          inputOnly      MFFloat	set_key IS set_key
          initializeOnly SFNode      keyHolderNode             USE KeyHolder
          outputOnly     MFFloat	key_changed IS key_changed
          inputOnly      MFVec2f	set_keyValue IS set_keyValue
          initializeOnly SFNode      keyValueHolderNode             USE KeyValueHolder
          outputOnly     MFVec2f	keyValue_changed IS keyValue_changed
          outputOnly     MFVec2f	value_changed IS value_changed
          directOutput TRUE
                                                                                   ### Warning:  'var' declarations of variables are not persistent in contained ecmascript: code, values are lost after each call. Use <field> definitions instead.

	url [ "ecmascript:
// ### X3D Browser.print() not supported by all VRML97 viewers, instead simply use print()


// internal global persistent variables
var previousFraction;
var previousFractionIndex;
var blockSize;
var outputArray;

function tracePrint (outputString)
{
	var traceEnabled = false;
	if (traceEnabled) Browser.print ('[CoordinateInterpolator2D] ' + outputString);
}
function forcePrint (outputString)
{
	Browser.print ('[CoordinateInterpolator2D] ' + outputString);
}
function initialize (timestamp)
{
	key      = keyHolderNode.key;
	keyValue = keyValueHolderNode.point;
	previousFractionIndex = -1;
	previousFraction = 0;
	// check key array ranges [0..1] and is monotonically increasing
	// check that size of keyValue array is integer multiple of size of key array
	tracePrint ('key            =' + key);
	tracePrint ('key.length=     ' + key.length);
	tracePrint ('keyValue=       ' + keyValue);
	tracePrint ('keyValue.length=' + keyValue.length);
	blockSize =  keyValue.length/key.length;
	tracePrint ('blockSize=' + blockSize);
	if (blockSize != Math.round(blockSize))
	{
	  forcePrint ('*** warning:  blockSize not an integer multiple. check sizes of key and keyValue');
	}
	if (key[0] != 0)
	{
	  forcePrint ('*** warning:  key[0] != 0');
	}
	if (key[key.length-1] != 1)
	{
	  forcePrint ('*** warning:  key[' + (key.length - 1) + '] != 1, reset from ' + key[key.length-1] + ' to 1');
	  key[key.length-1] = 1;
	}
	for (index = 0; index < blockSize; index++)
	{
		if ((key[index] < 0) || (key[index] > 1))
		{
		   forcePrint ('*** warning:  key[' + index + '] = ' + key[index] + ', out of range [0..1]');
		}
	}
	// instantiate default array, later computations just update it
	outputArray = new MFVec2f ();
	for (index = 0; index < blockSize; index++)
	{
		// dynamically grow outputArray to match initial block
		outputArray[index] = keyValue[index];
	}
	tracePrint ('initial outputArray=' + outputArray);
}

function set_fraction (inputFloat, timestamp) {
	fraction = inputFloat;
	tracePrint ('previousFractionIndex=' + previousFractionIndex
		 + ', fraction=' + fraction + ', previousFraction=' + previousFraction);

	if (fraction < 0)
	{
		tracePrint ('*** illegal fraction ' + fraction + ' set to 0');
		fraction = 0;
		previousFractionIndex = 0; // first
	}
	else if (fraction > 1)
	{
		forcePrint ('*** illegal fraction ' + fraction + ' set to 1');
		fraction = 1;
		previousFractionIndex = blockSize - 1; // last
	}
	else if (previousFractionIndex == -1)
	{
		previousFractionIndex = 0; // first
		tracePrint ('previousFractionIndex initialized for first event');
	}
	else if ((fraction >= previousFraction) && (fraction >= key[previousFractionIndex+1]))
	{
		previousFractionIndex++;
	}
	else if (fraction < previousFraction) // regress, or loop repeat without reaching one
	{
		previousFractionIndex = 0;
		while ((fraction >= key[previousFractionIndex+1]) && (previousFractionIndex < blockSize))
		{
			previousFractionIndex++;
		}
		tracePrint ('reset/reincrement previousFractionIndex to ' + previousFractionIndex);
	}

	if (fraction == 1) // use final block
	{
		tracePrint ('(fraction == 1)');
		for (index = 0; index < blockSize; index++)
		{
			// update outputArray with final four keyValues
			outputArray[4 - index] = keyValue[keyValue.length - index];
		}
		previousFractionIndex = -1; // setup for restart
		tracePrint ('finished final fraction==1 block');
	}
	// when fraction matches index, calculate value_changed from corresponding keyValue array
	else if (fraction == key[previousFractionIndex])
	{
		tracePrint ('(fraction == key[previousFractionIndex])');
		for (index = 0; index < blockSize; index++)
		{
			// update outputArray - need to interpolate next
			outputArray[index] = keyValue[blockSize * (previousFractionIndex) + index];
		}
	}
	else // calculate value_changed by interpolating between adjacent keyValue arrays
	{
		partialFraction = fraction                     - key[previousFractionIndex];
		deltaFraction   = key[previousFractionIndex+1] - key[previousFractionIndex];
		percentFraction = partialFraction / deltaFraction;
	//	tracePrint ('deltaFraction   = ' + deltaFraction);
	//	tracePrint ('partialFraction = ' + partialFraction);
		tracePrint ('percentFraction = ' + percentFraction);
		for (index = 0; index < blockSize; index++)
		{
			// no arithmetic operators provided for SFVec2f, treat element by element
			nextKeyValue  = keyValue[blockSize * (previousFractionIndex + 1) + index];
			priorKeyValue = keyValue[blockSize * (previousFractionIndex)     + index];
			deltaKeyValue = new SFVec2f (
						nextKeyValue[0] - priorKeyValue[0],
						nextKeyValue[1] - priorKeyValue[1]);
		//	tracePrint ('deltaKeyValue = ' + deltaKeyValue);
			// update outputArray
			outputArray[index][0] = keyValue[blockSize * (previousFractionIndex) + index][0]
			   + percentFraction * deltaKeyValue[0];
			outputArray[index][1] = keyValue[blockSize * (previousFractionIndex) + index][1]
			   + percentFraction * deltaKeyValue[1];
		}
	}
	value_changed = outputArray;
	previousFraction = fraction;
	tracePrint ('value_changed=' + value_changed);
}

function set_key (inputArray, timestamp) {
	key = inputArray;       // update key Vector2FloatArray
	keyHolderNode.key = key; // update holder
	initialize (timestamp); // reverify key, keyValue sizes
	key_changed = key;	// eventOut
}

function set_keyValue (inputArray, timestamp) {
	keyValue = inputArray;  	// update keyValue Vector2FloatArray
	keyValueHolderNode.point = keyValue; // update holder
	initialize (timestamp); 	// reverify key, keyValue sizes
	keyValue_changed = keyValue;	// eventOut
}
          
" ]
        }
    ]
  }
}
# ======================================
# Example use
Anchor {
  description "CoordinateInterpolator2dExample"
  parameter [ "target=_blank" ]
  url [ "CoordinateInterpolator2dExample.wrl"
"https://savage.nps.edu/Savage/Tools/Animation/CoordinateInterpolator2dExample.wrl"
"CoordinateInterpolator2dExample.x3d"
"https://savage.nps.edu/Savage/Tools/Animation/CoordinateInterpolator2dExample.x3d" ]
  children [
      Shape {
        geometry Text {
          string [ "CoordinateInterpolator2dPrototype" "defines a prototype" ""
"Click on this text to see" "CoordinateInterpolator2dExample" " scene" ]
          fontStyle FontStyle {
            justify [ "MIDDLE" "MIDDLE"  ] 
            size 0.7
          }
        }
        appearance Appearance {
          material Material {
            diffuseColor 1 1 0.2
          }
        }
      }
  ]
}
 ### Hint:  For maximum scene portability, append alternate online address for revised url=' "CoordinateInterpolator2dExample.wrl https://savage.nps.edu/Savage/Tools/Animation/CoordinateInterpolator2dExample.wrl CoordinateInterpolator2dExample.x3d https://savage.nps.edu/Savage/Tools/Animation/CoordinateInterpolator2dExample.x3d" "http://...address.../CoordinateInterpolator2dExample.wrl https://savage.nps.edu/Savage/Tools/Animation/CoordinateInterpolator2dExample.wrl CoordinateInterpolator2dExample.x3d https://savage.nps.edu/Savage/Tools/Animation/CoordinateInterpolator2dExample.x3d" '
